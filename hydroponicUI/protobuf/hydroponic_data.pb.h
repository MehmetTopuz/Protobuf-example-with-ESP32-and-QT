// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hydroponic_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hydroponic_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hydroponic_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hydroponic_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hydroponic_5fdata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hydroponic_5fdata_2eproto;
namespace hydroponic {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DataPackage;
class DataPackageDefaultTypeInternal;
extern DataPackageDefaultTypeInternal _DataPackage_default_instance_;
class HeartBeat;
class HeartBeatDefaultTypeInternal;
extern HeartBeatDefaultTypeInternal _HeartBeat_default_instance_;
class Hydroponic;
class HydroponicDefaultTypeInternal;
extern HydroponicDefaultTypeInternal _Hydroponic_default_instance_;
class MessageError;
class MessageErrorDefaultTypeInternal;
extern MessageErrorDefaultTypeInternal _MessageError_default_instance_;
class MessageOk;
class MessageOkDefaultTypeInternal;
extern MessageOkDefaultTypeInternal _MessageOk_default_instance_;
class MessageTimeout;
class MessageTimeoutDefaultTypeInternal;
extern MessageTimeoutDefaultTypeInternal _MessageTimeout_default_instance_;
}  // namespace hydroponic
PROTOBUF_NAMESPACE_OPEN
template<> ::hydroponic::Command* Arena::CreateMaybeMessage<::hydroponic::Command>(Arena*);
template<> ::hydroponic::DataPackage* Arena::CreateMaybeMessage<::hydroponic::DataPackage>(Arena*);
template<> ::hydroponic::HeartBeat* Arena::CreateMaybeMessage<::hydroponic::HeartBeat>(Arena*);
template<> ::hydroponic::Hydroponic* Arena::CreateMaybeMessage<::hydroponic::Hydroponic>(Arena*);
template<> ::hydroponic::MessageError* Arena::CreateMaybeMessage<::hydroponic::MessageError>(Arena*);
template<> ::hydroponic::MessageOk* Arena::CreateMaybeMessage<::hydroponic::MessageOk>(Arena*);
template<> ::hydroponic::MessageTimeout* Arena::CreateMaybeMessage<::hydroponic::MessageTimeout>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hydroponic {

enum MessageType : int {
  MSG_HEART_BEAT = 0,
  MSG_OK = 1,
  MSG_ERROR = 2,
  MSG_DATA = 3,
  MSG_TIMEOUT = 4,
  MSG_CMD = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MSG_HEART_BEAT;
constexpr MessageType MessageType_MAX = MSG_CMD;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum CMD : int {
  CMD_VALVE_ON = 0,
  CMD_VALVE_OFF = 1,
  CMD_PUMP_ON = 2,
  CMD_PUMP_OFF = 3,
  CMD_LED_ON = 4,
  CMD_LED_OFF = 5,
  CMD_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CMD_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CMD_IsValid(int value);
constexpr CMD CMD_MIN = CMD_VALVE_ON;
constexpr CMD CMD_MAX = CMD_LED_OFF;
constexpr int CMD_ARRAYSIZE = CMD_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMD_descriptor();
template<typename T>
inline const std::string& CMD_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMD>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMD_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMD_descriptor(), enum_t_value);
}
inline bool CMD_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMD* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMD>(
    CMD_descriptor(), name, value);
}
// ===================================================================

class Hydroponic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.Hydroponic) */ {
 public:
  inline Hydroponic() : Hydroponic(nullptr) {}
  virtual ~Hydroponic();

  Hydroponic(const Hydroponic& from);
  Hydroponic(Hydroponic&& from) noexcept
    : Hydroponic() {
    *this = ::std::move(from);
  }

  inline Hydroponic& operator=(const Hydroponic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hydroponic& operator=(Hydroponic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Hydroponic& default_instance();

  enum MsgCase {
    kDataPackage = 2,
    kHeartBeat = 3,
    kMessageOk = 4,
    kMessageError = 5,
    kMessageTimeout = 6,
    kCmd = 7,
    MSG_NOT_SET = 0,
  };

  static inline const Hydroponic* internal_default_instance() {
    return reinterpret_cast<const Hydroponic*>(
               &_Hydroponic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hydroponic& a, Hydroponic& b) {
    a.Swap(&b);
  }
  inline void Swap(Hydroponic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hydroponic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Hydroponic* New() const final {
    return CreateMaybeMessage<Hydroponic>(nullptr);
  }

  Hydroponic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Hydroponic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Hydroponic& from);
  void MergeFrom(const Hydroponic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hydroponic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.Hydroponic";
  }
  protected:
  explicit Hydroponic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kDataPackageFieldNumber = 2,
    kHeartBeatFieldNumber = 3,
    kMessageOkFieldNumber = 4,
    kMessageErrorFieldNumber = 5,
    kMessageTimeoutFieldNumber = 6,
    kCmdFieldNumber = 7,
  };
  // .hydroponic.MessageType messageType = 1;
  void clear_messagetype();
  ::hydroponic::MessageType messagetype() const;
  void set_messagetype(::hydroponic::MessageType value);
  private:
  ::hydroponic::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::hydroponic::MessageType value);
  public:

  // .hydroponic.DataPackage dataPackage = 2;
  bool has_datapackage() const;
  private:
  bool _internal_has_datapackage() const;
  public:
  void clear_datapackage();
  const ::hydroponic::DataPackage& datapackage() const;
  ::hydroponic::DataPackage* release_datapackage();
  ::hydroponic::DataPackage* mutable_datapackage();
  void set_allocated_datapackage(::hydroponic::DataPackage* datapackage);
  private:
  const ::hydroponic::DataPackage& _internal_datapackage() const;
  ::hydroponic::DataPackage* _internal_mutable_datapackage();
  public:
  void unsafe_arena_set_allocated_datapackage(
      ::hydroponic::DataPackage* datapackage);
  ::hydroponic::DataPackage* unsafe_arena_release_datapackage();

  // .hydroponic.HeartBeat heartBeat = 3;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::hydroponic::HeartBeat& heartbeat() const;
  ::hydroponic::HeartBeat* release_heartbeat();
  ::hydroponic::HeartBeat* mutable_heartbeat();
  void set_allocated_heartbeat(::hydroponic::HeartBeat* heartbeat);
  private:
  const ::hydroponic::HeartBeat& _internal_heartbeat() const;
  ::hydroponic::HeartBeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::hydroponic::HeartBeat* heartbeat);
  ::hydroponic::HeartBeat* unsafe_arena_release_heartbeat();

  // .hydroponic.MessageOk messageOk = 4;
  bool has_messageok() const;
  private:
  bool _internal_has_messageok() const;
  public:
  void clear_messageok();
  const ::hydroponic::MessageOk& messageok() const;
  ::hydroponic::MessageOk* release_messageok();
  ::hydroponic::MessageOk* mutable_messageok();
  void set_allocated_messageok(::hydroponic::MessageOk* messageok);
  private:
  const ::hydroponic::MessageOk& _internal_messageok() const;
  ::hydroponic::MessageOk* _internal_mutable_messageok();
  public:
  void unsafe_arena_set_allocated_messageok(
      ::hydroponic::MessageOk* messageok);
  ::hydroponic::MessageOk* unsafe_arena_release_messageok();

  // .hydroponic.MessageError messageError = 5;
  bool has_messageerror() const;
  private:
  bool _internal_has_messageerror() const;
  public:
  void clear_messageerror();
  const ::hydroponic::MessageError& messageerror() const;
  ::hydroponic::MessageError* release_messageerror();
  ::hydroponic::MessageError* mutable_messageerror();
  void set_allocated_messageerror(::hydroponic::MessageError* messageerror);
  private:
  const ::hydroponic::MessageError& _internal_messageerror() const;
  ::hydroponic::MessageError* _internal_mutable_messageerror();
  public:
  void unsafe_arena_set_allocated_messageerror(
      ::hydroponic::MessageError* messageerror);
  ::hydroponic::MessageError* unsafe_arena_release_messageerror();

  // .hydroponic.MessageTimeout messageTimeout = 6;
  bool has_messagetimeout() const;
  private:
  bool _internal_has_messagetimeout() const;
  public:
  void clear_messagetimeout();
  const ::hydroponic::MessageTimeout& messagetimeout() const;
  ::hydroponic::MessageTimeout* release_messagetimeout();
  ::hydroponic::MessageTimeout* mutable_messagetimeout();
  void set_allocated_messagetimeout(::hydroponic::MessageTimeout* messagetimeout);
  private:
  const ::hydroponic::MessageTimeout& _internal_messagetimeout() const;
  ::hydroponic::MessageTimeout* _internal_mutable_messagetimeout();
  public:
  void unsafe_arena_set_allocated_messagetimeout(
      ::hydroponic::MessageTimeout* messagetimeout);
  ::hydroponic::MessageTimeout* unsafe_arena_release_messagetimeout();

  // .hydroponic.Command cmd = 7;
  bool has_cmd() const;
  private:
  bool _internal_has_cmd() const;
  public:
  void clear_cmd();
  const ::hydroponic::Command& cmd() const;
  ::hydroponic::Command* release_cmd();
  ::hydroponic::Command* mutable_cmd();
  void set_allocated_cmd(::hydroponic::Command* cmd);
  private:
  const ::hydroponic::Command& _internal_cmd() const;
  ::hydroponic::Command* _internal_mutable_cmd();
  public:
  void unsafe_arena_set_allocated_cmd(
      ::hydroponic::Command* cmd);
  ::hydroponic::Command* unsafe_arena_release_cmd();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:hydroponic.Hydroponic)
 private:
  class _Internal;
  void set_has_datapackage();
  void set_has_heartbeat();
  void set_has_messageok();
  void set_has_messageerror();
  void set_has_messagetimeout();
  void set_has_cmd();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int messagetype_;
  union MsgUnion {
    MsgUnion() {}
    ::hydroponic::DataPackage* datapackage_;
    ::hydroponic::HeartBeat* heartbeat_;
    ::hydroponic::MessageOk* messageok_;
    ::hydroponic::MessageError* messageerror_;
    ::hydroponic::MessageTimeout* messagetimeout_;
    ::hydroponic::Command* cmd_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DataPackage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.DataPackage) */ {
 public:
  inline DataPackage() : DataPackage(nullptr) {}
  virtual ~DataPackage();

  DataPackage(const DataPackage& from);
  DataPackage(DataPackage&& from) noexcept
    : DataPackage() {
    *this = ::std::move(from);
  }

  inline DataPackage& operator=(const DataPackage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPackage& operator=(DataPackage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPackage& default_instance();

  static inline const DataPackage* internal_default_instance() {
    return reinterpret_cast<const DataPackage*>(
               &_DataPackage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataPackage& a, DataPackage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPackage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPackage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPackage* New() const final {
    return CreateMaybeMessage<DataPackage>(nullptr);
  }

  DataPackage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPackage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPackage& from);
  void MergeFrom(const DataPackage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPackage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.DataPackage";
  }
  protected:
  explicit DataPackage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorFieldNumber = 3,
    kDeviceIDFieldNumber = 2,
    kEConductivityFieldNumber = 4,
    kPhFieldNumber = 5,
    kMoistureFieldNumber = 6,
    kTemperatureFieldNumber = 7,
    kWaterLevelFieldNumber = 8,
    kValveStateFieldNumber = 9,
    kPumpStateFieldNumber = 10,
    kLedStatusFieldNumber = 11,
  };
  // string sector = 3;
  void clear_sector();
  const std::string& sector() const;
  void set_sector(const std::string& value);
  void set_sector(std::string&& value);
  void set_sector(const char* value);
  void set_sector(const char* value, size_t size);
  std::string* mutable_sector();
  std::string* release_sector();
  void set_allocated_sector(std::string* sector);
  private:
  const std::string& _internal_sector() const;
  void _internal_set_sector(const std::string& value);
  std::string* _internal_mutable_sector();
  public:

  // uint32 deviceID = 2;
  void clear_deviceid();
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid() const;
  void set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_deviceid() const;
  void _internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float eConductivity = 4;
  void clear_econductivity();
  float econductivity() const;
  void set_econductivity(float value);
  private:
  float _internal_econductivity() const;
  void _internal_set_econductivity(float value);
  public:

  // float ph = 5;
  void clear_ph();
  float ph() const;
  void set_ph(float value);
  private:
  float _internal_ph() const;
  void _internal_set_ph(float value);
  public:

  // float moisture = 6;
  void clear_moisture();
  float moisture() const;
  void set_moisture(float value);
  private:
  float _internal_moisture() const;
  void _internal_set_moisture(float value);
  public:

  // float temperature = 7;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // uint32 waterLevel = 8;
  void clear_waterlevel();
  ::PROTOBUF_NAMESPACE_ID::uint32 waterlevel() const;
  void set_waterlevel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_waterlevel() const;
  void _internal_set_waterlevel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool valveState = 9;
  void clear_valvestate();
  bool valvestate() const;
  void set_valvestate(bool value);
  private:
  bool _internal_valvestate() const;
  void _internal_set_valvestate(bool value);
  public:

  // bool pumpState = 10;
  void clear_pumpstate();
  bool pumpstate() const;
  void set_pumpstate(bool value);
  private:
  bool _internal_pumpstate() const;
  void _internal_set_pumpstate(bool value);
  public:

  // bool ledStatus = 11;
  void clear_ledstatus();
  bool ledstatus() const;
  void set_ledstatus(bool value);
  private:
  bool _internal_ledstatus() const;
  void _internal_set_ledstatus(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.DataPackage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sector_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid_;
  float econductivity_;
  float ph_;
  float moisture_;
  float temperature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 waterlevel_;
  bool valvestate_;
  bool pumpstate_;
  bool ledstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class HeartBeat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.HeartBeat) */ {
 public:
  inline HeartBeat() : HeartBeat(nullptr) {}
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);
  HeartBeat(HeartBeat&& from) noexcept
    : HeartBeat() {
    *this = ::std::move(from);
  }

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeat& operator=(HeartBeat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartBeat& default_instance();

  static inline const HeartBeat* internal_default_instance() {
    return reinterpret_cast<const HeartBeat*>(
               &_HeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HeartBeat& a, HeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const final {
    return CreateMaybeMessage<HeartBeat>(nullptr);
  }

  HeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.HeartBeat";
  }
  protected:
  explicit HeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElapsedTimeFieldNumber = 1,
  };
  // uint32 elapsedTime = 1;
  void clear_elapsedtime();
  ::PROTOBUF_NAMESPACE_ID::uint32 elapsedtime() const;
  void set_elapsedtime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_elapsedtime() const;
  void _internal_set_elapsedtime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.HeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 elapsedtime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class MessageOk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.MessageOk) */ {
 public:
  inline MessageOk() : MessageOk(nullptr) {}
  virtual ~MessageOk();

  MessageOk(const MessageOk& from);
  MessageOk(MessageOk&& from) noexcept
    : MessageOk() {
    *this = ::std::move(from);
  }

  inline MessageOk& operator=(const MessageOk& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageOk& operator=(MessageOk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageOk& default_instance();

  static inline const MessageOk* internal_default_instance() {
    return reinterpret_cast<const MessageOk*>(
               &_MessageOk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MessageOk& a, MessageOk& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageOk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageOk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageOk* New() const final {
    return CreateMaybeMessage<MessageOk>(nullptr);
  }

  MessageOk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageOk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageOk& from);
  void MergeFrom(const MessageOk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageOk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.MessageOk";
  }
  protected:
  explicit MessageOk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseMessageFieldNumber = 1,
  };
  // string responseMessage = 1;
  void clear_responsemessage();
  const std::string& responsemessage() const;
  void set_responsemessage(const std::string& value);
  void set_responsemessage(std::string&& value);
  void set_responsemessage(const char* value);
  void set_responsemessage(const char* value, size_t size);
  std::string* mutable_responsemessage();
  std::string* release_responsemessage();
  void set_allocated_responsemessage(std::string* responsemessage);
  private:
  const std::string& _internal_responsemessage() const;
  void _internal_set_responsemessage(const std::string& value);
  std::string* _internal_mutable_responsemessage();
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.MessageOk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsemessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class MessageError PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.MessageError) */ {
 public:
  inline MessageError() : MessageError(nullptr) {}
  virtual ~MessageError();

  MessageError(const MessageError& from);
  MessageError(MessageError&& from) noexcept
    : MessageError() {
    *this = ::std::move(from);
  }

  inline MessageError& operator=(const MessageError& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageError& operator=(MessageError&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageError& default_instance();

  static inline const MessageError* internal_default_instance() {
    return reinterpret_cast<const MessageError*>(
               &_MessageError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MessageError& a, MessageError& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageError* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageError* New() const final {
    return CreateMaybeMessage<MessageError>(nullptr);
  }

  MessageError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageError& from);
  void MergeFrom(const MessageError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.MessageError";
  }
  protected:
  explicit MessageError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorTypeFieldNumber = 1,
  };
  // string errorType = 1;
  void clear_errortype();
  const std::string& errortype() const;
  void set_errortype(const std::string& value);
  void set_errortype(std::string&& value);
  void set_errortype(const char* value);
  void set_errortype(const char* value, size_t size);
  std::string* mutable_errortype();
  std::string* release_errortype();
  void set_allocated_errortype(std::string* errortype);
  private:
  const std::string& _internal_errortype() const;
  void _internal_set_errortype(const std::string& value);
  std::string* _internal_mutable_errortype();
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.MessageError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errortype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class MessageTimeout PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.MessageTimeout) */ {
 public:
  inline MessageTimeout() : MessageTimeout(nullptr) {}
  virtual ~MessageTimeout();

  MessageTimeout(const MessageTimeout& from);
  MessageTimeout(MessageTimeout&& from) noexcept
    : MessageTimeout() {
    *this = ::std::move(from);
  }

  inline MessageTimeout& operator=(const MessageTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageTimeout& operator=(MessageTimeout&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageTimeout& default_instance();

  static inline const MessageTimeout* internal_default_instance() {
    return reinterpret_cast<const MessageTimeout*>(
               &_MessageTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MessageTimeout& a, MessageTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageTimeout* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageTimeout* New() const final {
    return CreateMaybeMessage<MessageTimeout>(nullptr);
  }

  MessageTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageTimeout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageTimeout& from);
  void MergeFrom(const MessageTimeout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageTimeout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.MessageTimeout";
  }
  protected:
  explicit MessageTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutMessageFieldNumber = 1,
  };
  // string timeoutMessage = 1;
  void clear_timeoutmessage();
  const std::string& timeoutmessage() const;
  void set_timeoutmessage(const std::string& value);
  void set_timeoutmessage(std::string&& value);
  void set_timeoutmessage(const char* value);
  void set_timeoutmessage(const char* value, size_t size);
  std::string* mutable_timeoutmessage();
  std::string* release_timeoutmessage();
  void set_allocated_timeoutmessage(std::string* timeoutmessage);
  private:
  const std::string& _internal_timeoutmessage() const;
  void _internal_set_timeoutmessage(const std::string& value);
  std::string* _internal_mutable_timeoutmessage();
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.MessageTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeoutmessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hydroponic.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hydroponic.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hydroponic_5fdata_2eproto);
    return ::descriptor_table_hydroponic_5fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .hydroponic.CMD command = 1;
  void clear_command();
  ::hydroponic::CMD command() const;
  void set_command(::hydroponic::CMD value);
  private:
  ::hydroponic::CMD _internal_command() const;
  void _internal_set_command(::hydroponic::CMD value);
  public:

  // @@protoc_insertion_point(class_scope:hydroponic.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hydroponic_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hydroponic

// .hydroponic.MessageType messageType = 1;
inline void Hydroponic::clear_messagetype() {
  messagetype_ = 0;
}
inline ::hydroponic::MessageType Hydroponic::_internal_messagetype() const {
  return static_cast< ::hydroponic::MessageType >(messagetype_);
}
inline ::hydroponic::MessageType Hydroponic::messagetype() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.messageType)
  return _internal_messagetype();
}
inline void Hydroponic::_internal_set_messagetype(::hydroponic::MessageType value) {
  
  messagetype_ = value;
}
inline void Hydroponic::set_messagetype(::hydroponic::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:hydroponic.Hydroponic.messageType)
}

// .hydroponic.DataPackage dataPackage = 2;
inline bool Hydroponic::_internal_has_datapackage() const {
  return msg_case() == kDataPackage;
}
inline bool Hydroponic::has_datapackage() const {
  return _internal_has_datapackage();
}
inline void Hydroponic::set_has_datapackage() {
  _oneof_case_[0] = kDataPackage;
}
inline void Hydroponic::clear_datapackage() {
  if (_internal_has_datapackage()) {
    if (GetArena() == nullptr) {
      delete msg_.datapackage_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::DataPackage* Hydroponic::release_datapackage() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.dataPackage)
  if (_internal_has_datapackage()) {
    clear_has_msg();
      ::hydroponic::DataPackage* temp = msg_.datapackage_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.datapackage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::DataPackage& Hydroponic::_internal_datapackage() const {
  return _internal_has_datapackage()
      ? *msg_.datapackage_
      : reinterpret_cast< ::hydroponic::DataPackage&>(::hydroponic::_DataPackage_default_instance_);
}
inline const ::hydroponic::DataPackage& Hydroponic::datapackage() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.dataPackage)
  return _internal_datapackage();
}
inline ::hydroponic::DataPackage* Hydroponic::unsafe_arena_release_datapackage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.dataPackage)
  if (_internal_has_datapackage()) {
    clear_has_msg();
    ::hydroponic::DataPackage* temp = msg_.datapackage_;
    msg_.datapackage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_datapackage(::hydroponic::DataPackage* datapackage) {
  clear_msg();
  if (datapackage) {
    set_has_datapackage();
    msg_.datapackage_ = datapackage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.dataPackage)
}
inline ::hydroponic::DataPackage* Hydroponic::_internal_mutable_datapackage() {
  if (!_internal_has_datapackage()) {
    clear_msg();
    set_has_datapackage();
    msg_.datapackage_ = CreateMaybeMessage< ::hydroponic::DataPackage >(GetArena());
  }
  return msg_.datapackage_;
}
inline ::hydroponic::DataPackage* Hydroponic::mutable_datapackage() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.dataPackage)
  return _internal_mutable_datapackage();
}

// .hydroponic.HeartBeat heartBeat = 3;
inline bool Hydroponic::_internal_has_heartbeat() const {
  return msg_case() == kHeartBeat;
}
inline bool Hydroponic::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void Hydroponic::set_has_heartbeat() {
  _oneof_case_[0] = kHeartBeat;
}
inline void Hydroponic::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArena() == nullptr) {
      delete msg_.heartbeat_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::HeartBeat* Hydroponic::release_heartbeat() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.heartBeat)
  if (_internal_has_heartbeat()) {
    clear_has_msg();
      ::hydroponic::HeartBeat* temp = msg_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::HeartBeat& Hydroponic::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *msg_.heartbeat_
      : reinterpret_cast< ::hydroponic::HeartBeat&>(::hydroponic::_HeartBeat_default_instance_);
}
inline const ::hydroponic::HeartBeat& Hydroponic::heartbeat() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.heartBeat)
  return _internal_heartbeat();
}
inline ::hydroponic::HeartBeat* Hydroponic::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.heartBeat)
  if (_internal_has_heartbeat()) {
    clear_has_msg();
    ::hydroponic::HeartBeat* temp = msg_.heartbeat_;
    msg_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_heartbeat(::hydroponic::HeartBeat* heartbeat) {
  clear_msg();
  if (heartbeat) {
    set_has_heartbeat();
    msg_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.heartBeat)
}
inline ::hydroponic::HeartBeat* Hydroponic::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_msg();
    set_has_heartbeat();
    msg_.heartbeat_ = CreateMaybeMessage< ::hydroponic::HeartBeat >(GetArena());
  }
  return msg_.heartbeat_;
}
inline ::hydroponic::HeartBeat* Hydroponic::mutable_heartbeat() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.heartBeat)
  return _internal_mutable_heartbeat();
}

// .hydroponic.MessageOk messageOk = 4;
inline bool Hydroponic::_internal_has_messageok() const {
  return msg_case() == kMessageOk;
}
inline bool Hydroponic::has_messageok() const {
  return _internal_has_messageok();
}
inline void Hydroponic::set_has_messageok() {
  _oneof_case_[0] = kMessageOk;
}
inline void Hydroponic::clear_messageok() {
  if (_internal_has_messageok()) {
    if (GetArena() == nullptr) {
      delete msg_.messageok_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::MessageOk* Hydroponic::release_messageok() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.messageOk)
  if (_internal_has_messageok()) {
    clear_has_msg();
      ::hydroponic::MessageOk* temp = msg_.messageok_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.messageok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::MessageOk& Hydroponic::_internal_messageok() const {
  return _internal_has_messageok()
      ? *msg_.messageok_
      : reinterpret_cast< ::hydroponic::MessageOk&>(::hydroponic::_MessageOk_default_instance_);
}
inline const ::hydroponic::MessageOk& Hydroponic::messageok() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.messageOk)
  return _internal_messageok();
}
inline ::hydroponic::MessageOk* Hydroponic::unsafe_arena_release_messageok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.messageOk)
  if (_internal_has_messageok()) {
    clear_has_msg();
    ::hydroponic::MessageOk* temp = msg_.messageok_;
    msg_.messageok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_messageok(::hydroponic::MessageOk* messageok) {
  clear_msg();
  if (messageok) {
    set_has_messageok();
    msg_.messageok_ = messageok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.messageOk)
}
inline ::hydroponic::MessageOk* Hydroponic::_internal_mutable_messageok() {
  if (!_internal_has_messageok()) {
    clear_msg();
    set_has_messageok();
    msg_.messageok_ = CreateMaybeMessage< ::hydroponic::MessageOk >(GetArena());
  }
  return msg_.messageok_;
}
inline ::hydroponic::MessageOk* Hydroponic::mutable_messageok() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.messageOk)
  return _internal_mutable_messageok();
}

// .hydroponic.MessageError messageError = 5;
inline bool Hydroponic::_internal_has_messageerror() const {
  return msg_case() == kMessageError;
}
inline bool Hydroponic::has_messageerror() const {
  return _internal_has_messageerror();
}
inline void Hydroponic::set_has_messageerror() {
  _oneof_case_[0] = kMessageError;
}
inline void Hydroponic::clear_messageerror() {
  if (_internal_has_messageerror()) {
    if (GetArena() == nullptr) {
      delete msg_.messageerror_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::MessageError* Hydroponic::release_messageerror() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.messageError)
  if (_internal_has_messageerror()) {
    clear_has_msg();
      ::hydroponic::MessageError* temp = msg_.messageerror_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.messageerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::MessageError& Hydroponic::_internal_messageerror() const {
  return _internal_has_messageerror()
      ? *msg_.messageerror_
      : reinterpret_cast< ::hydroponic::MessageError&>(::hydroponic::_MessageError_default_instance_);
}
inline const ::hydroponic::MessageError& Hydroponic::messageerror() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.messageError)
  return _internal_messageerror();
}
inline ::hydroponic::MessageError* Hydroponic::unsafe_arena_release_messageerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.messageError)
  if (_internal_has_messageerror()) {
    clear_has_msg();
    ::hydroponic::MessageError* temp = msg_.messageerror_;
    msg_.messageerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_messageerror(::hydroponic::MessageError* messageerror) {
  clear_msg();
  if (messageerror) {
    set_has_messageerror();
    msg_.messageerror_ = messageerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.messageError)
}
inline ::hydroponic::MessageError* Hydroponic::_internal_mutable_messageerror() {
  if (!_internal_has_messageerror()) {
    clear_msg();
    set_has_messageerror();
    msg_.messageerror_ = CreateMaybeMessage< ::hydroponic::MessageError >(GetArena());
  }
  return msg_.messageerror_;
}
inline ::hydroponic::MessageError* Hydroponic::mutable_messageerror() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.messageError)
  return _internal_mutable_messageerror();
}

// .hydroponic.MessageTimeout messageTimeout = 6;
inline bool Hydroponic::_internal_has_messagetimeout() const {
  return msg_case() == kMessageTimeout;
}
inline bool Hydroponic::has_messagetimeout() const {
  return _internal_has_messagetimeout();
}
inline void Hydroponic::set_has_messagetimeout() {
  _oneof_case_[0] = kMessageTimeout;
}
inline void Hydroponic::clear_messagetimeout() {
  if (_internal_has_messagetimeout()) {
    if (GetArena() == nullptr) {
      delete msg_.messagetimeout_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::MessageTimeout* Hydroponic::release_messagetimeout() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.messageTimeout)
  if (_internal_has_messagetimeout()) {
    clear_has_msg();
      ::hydroponic::MessageTimeout* temp = msg_.messagetimeout_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.messagetimeout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::MessageTimeout& Hydroponic::_internal_messagetimeout() const {
  return _internal_has_messagetimeout()
      ? *msg_.messagetimeout_
      : reinterpret_cast< ::hydroponic::MessageTimeout&>(::hydroponic::_MessageTimeout_default_instance_);
}
inline const ::hydroponic::MessageTimeout& Hydroponic::messagetimeout() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.messageTimeout)
  return _internal_messagetimeout();
}
inline ::hydroponic::MessageTimeout* Hydroponic::unsafe_arena_release_messagetimeout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.messageTimeout)
  if (_internal_has_messagetimeout()) {
    clear_has_msg();
    ::hydroponic::MessageTimeout* temp = msg_.messagetimeout_;
    msg_.messagetimeout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_messagetimeout(::hydroponic::MessageTimeout* messagetimeout) {
  clear_msg();
  if (messagetimeout) {
    set_has_messagetimeout();
    msg_.messagetimeout_ = messagetimeout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.messageTimeout)
}
inline ::hydroponic::MessageTimeout* Hydroponic::_internal_mutable_messagetimeout() {
  if (!_internal_has_messagetimeout()) {
    clear_msg();
    set_has_messagetimeout();
    msg_.messagetimeout_ = CreateMaybeMessage< ::hydroponic::MessageTimeout >(GetArena());
  }
  return msg_.messagetimeout_;
}
inline ::hydroponic::MessageTimeout* Hydroponic::mutable_messagetimeout() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.messageTimeout)
  return _internal_mutable_messagetimeout();
}

// .hydroponic.Command cmd = 7;
inline bool Hydroponic::_internal_has_cmd() const {
  return msg_case() == kCmd;
}
inline bool Hydroponic::has_cmd() const {
  return _internal_has_cmd();
}
inline void Hydroponic::set_has_cmd() {
  _oneof_case_[0] = kCmd;
}
inline void Hydroponic::clear_cmd() {
  if (_internal_has_cmd()) {
    if (GetArena() == nullptr) {
      delete msg_.cmd_;
    }
    clear_has_msg();
  }
}
inline ::hydroponic::Command* Hydroponic::release_cmd() {
  // @@protoc_insertion_point(field_release:hydroponic.Hydroponic.cmd)
  if (_internal_has_cmd()) {
    clear_has_msg();
      ::hydroponic::Command* temp = msg_.cmd_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hydroponic::Command& Hydroponic::_internal_cmd() const {
  return _internal_has_cmd()
      ? *msg_.cmd_
      : reinterpret_cast< ::hydroponic::Command&>(::hydroponic::_Command_default_instance_);
}
inline const ::hydroponic::Command& Hydroponic::cmd() const {
  // @@protoc_insertion_point(field_get:hydroponic.Hydroponic.cmd)
  return _internal_cmd();
}
inline ::hydroponic::Command* Hydroponic::unsafe_arena_release_cmd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hydroponic.Hydroponic.cmd)
  if (_internal_has_cmd()) {
    clear_has_msg();
    ::hydroponic::Command* temp = msg_.cmd_;
    msg_.cmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Hydroponic::unsafe_arena_set_allocated_cmd(::hydroponic::Command* cmd) {
  clear_msg();
  if (cmd) {
    set_has_cmd();
    msg_.cmd_ = cmd;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hydroponic.Hydroponic.cmd)
}
inline ::hydroponic::Command* Hydroponic::_internal_mutable_cmd() {
  if (!_internal_has_cmd()) {
    clear_msg();
    set_has_cmd();
    msg_.cmd_ = CreateMaybeMessage< ::hydroponic::Command >(GetArena());
  }
  return msg_.cmd_;
}
inline ::hydroponic::Command* Hydroponic::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable:hydroponic.Hydroponic.cmd)
  return _internal_mutable_cmd();
}

inline bool Hydroponic::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Hydroponic::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Hydroponic::MsgCase Hydroponic::msg_case() const {
  return Hydroponic::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataPackage

// uint32 deviceID = 2;
inline void DataPackage::clear_deviceid() {
  deviceid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPackage::_internal_deviceid() const {
  return deviceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPackage::deviceid() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.deviceID)
  return _internal_deviceid();
}
inline void DataPackage::_internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  deviceid_ = value;
}
inline void DataPackage::set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.deviceID)
}

// string sector = 3;
inline void DataPackage::clear_sector() {
  sector_.ClearToEmpty();
}
inline const std::string& DataPackage::sector() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.sector)
  return _internal_sector();
}
inline void DataPackage::set_sector(const std::string& value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.sector)
}
inline std::string* DataPackage::mutable_sector() {
  // @@protoc_insertion_point(field_mutable:hydroponic.DataPackage.sector)
  return _internal_mutable_sector();
}
inline const std::string& DataPackage::_internal_sector() const {
  return sector_.Get();
}
inline void DataPackage::_internal_set_sector(const std::string& value) {
  
  sector_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataPackage::set_sector(std::string&& value) {
  
  sector_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hydroponic.DataPackage.sector)
}
inline void DataPackage::set_sector(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sector_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:hydroponic.DataPackage.sector)
}
inline void DataPackage::set_sector(const char* value,
    size_t size) {
  
  sector_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hydroponic.DataPackage.sector)
}
inline std::string* DataPackage::_internal_mutable_sector() {
  
  return sector_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataPackage::release_sector() {
  // @@protoc_insertion_point(field_release:hydroponic.DataPackage.sector)
  return sector_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataPackage::set_allocated_sector(std::string* sector) {
  if (sector != nullptr) {
    
  } else {
    
  }
  sector_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sector,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hydroponic.DataPackage.sector)
}

// float eConductivity = 4;
inline void DataPackage::clear_econductivity() {
  econductivity_ = 0;
}
inline float DataPackage::_internal_econductivity() const {
  return econductivity_;
}
inline float DataPackage::econductivity() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.eConductivity)
  return _internal_econductivity();
}
inline void DataPackage::_internal_set_econductivity(float value) {
  
  econductivity_ = value;
}
inline void DataPackage::set_econductivity(float value) {
  _internal_set_econductivity(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.eConductivity)
}

// float ph = 5;
inline void DataPackage::clear_ph() {
  ph_ = 0;
}
inline float DataPackage::_internal_ph() const {
  return ph_;
}
inline float DataPackage::ph() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.ph)
  return _internal_ph();
}
inline void DataPackage::_internal_set_ph(float value) {
  
  ph_ = value;
}
inline void DataPackage::set_ph(float value) {
  _internal_set_ph(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.ph)
}

// float moisture = 6;
inline void DataPackage::clear_moisture() {
  moisture_ = 0;
}
inline float DataPackage::_internal_moisture() const {
  return moisture_;
}
inline float DataPackage::moisture() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.moisture)
  return _internal_moisture();
}
inline void DataPackage::_internal_set_moisture(float value) {
  
  moisture_ = value;
}
inline void DataPackage::set_moisture(float value) {
  _internal_set_moisture(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.moisture)
}

// float temperature = 7;
inline void DataPackage::clear_temperature() {
  temperature_ = 0;
}
inline float DataPackage::_internal_temperature() const {
  return temperature_;
}
inline float DataPackage::temperature() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.temperature)
  return _internal_temperature();
}
inline void DataPackage::_internal_set_temperature(float value) {
  
  temperature_ = value;
}
inline void DataPackage::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.temperature)
}

// uint32 waterLevel = 8;
inline void DataPackage::clear_waterlevel() {
  waterlevel_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPackage::_internal_waterlevel() const {
  return waterlevel_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPackage::waterlevel() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.waterLevel)
  return _internal_waterlevel();
}
inline void DataPackage::_internal_set_waterlevel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  waterlevel_ = value;
}
inline void DataPackage::set_waterlevel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_waterlevel(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.waterLevel)
}

// bool valveState = 9;
inline void DataPackage::clear_valvestate() {
  valvestate_ = false;
}
inline bool DataPackage::_internal_valvestate() const {
  return valvestate_;
}
inline bool DataPackage::valvestate() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.valveState)
  return _internal_valvestate();
}
inline void DataPackage::_internal_set_valvestate(bool value) {
  
  valvestate_ = value;
}
inline void DataPackage::set_valvestate(bool value) {
  _internal_set_valvestate(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.valveState)
}

// bool pumpState = 10;
inline void DataPackage::clear_pumpstate() {
  pumpstate_ = false;
}
inline bool DataPackage::_internal_pumpstate() const {
  return pumpstate_;
}
inline bool DataPackage::pumpstate() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.pumpState)
  return _internal_pumpstate();
}
inline void DataPackage::_internal_set_pumpstate(bool value) {
  
  pumpstate_ = value;
}
inline void DataPackage::set_pumpstate(bool value) {
  _internal_set_pumpstate(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.pumpState)
}

// bool ledStatus = 11;
inline void DataPackage::clear_ledstatus() {
  ledstatus_ = false;
}
inline bool DataPackage::_internal_ledstatus() const {
  return ledstatus_;
}
inline bool DataPackage::ledstatus() const {
  // @@protoc_insertion_point(field_get:hydroponic.DataPackage.ledStatus)
  return _internal_ledstatus();
}
inline void DataPackage::_internal_set_ledstatus(bool value) {
  
  ledstatus_ = value;
}
inline void DataPackage::set_ledstatus(bool value) {
  _internal_set_ledstatus(value);
  // @@protoc_insertion_point(field_set:hydroponic.DataPackage.ledStatus)
}

// -------------------------------------------------------------------

// HeartBeat

// uint32 elapsedTime = 1;
inline void HeartBeat::clear_elapsedtime() {
  elapsedtime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HeartBeat::_internal_elapsedtime() const {
  return elapsedtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HeartBeat::elapsedtime() const {
  // @@protoc_insertion_point(field_get:hydroponic.HeartBeat.elapsedTime)
  return _internal_elapsedtime();
}
inline void HeartBeat::_internal_set_elapsedtime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  elapsedtime_ = value;
}
inline void HeartBeat::set_elapsedtime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_elapsedtime(value);
  // @@protoc_insertion_point(field_set:hydroponic.HeartBeat.elapsedTime)
}

// -------------------------------------------------------------------

// MessageOk

// string responseMessage = 1;
inline void MessageOk::clear_responsemessage() {
  responsemessage_.ClearToEmpty();
}
inline const std::string& MessageOk::responsemessage() const {
  // @@protoc_insertion_point(field_get:hydroponic.MessageOk.responseMessage)
  return _internal_responsemessage();
}
inline void MessageOk::set_responsemessage(const std::string& value) {
  _internal_set_responsemessage(value);
  // @@protoc_insertion_point(field_set:hydroponic.MessageOk.responseMessage)
}
inline std::string* MessageOk::mutable_responsemessage() {
  // @@protoc_insertion_point(field_mutable:hydroponic.MessageOk.responseMessage)
  return _internal_mutable_responsemessage();
}
inline const std::string& MessageOk::_internal_responsemessage() const {
  return responsemessage_.Get();
}
inline void MessageOk::_internal_set_responsemessage(const std::string& value) {
  
  responsemessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MessageOk::set_responsemessage(std::string&& value) {
  
  responsemessage_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hydroponic.MessageOk.responseMessage)
}
inline void MessageOk::set_responsemessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  responsemessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:hydroponic.MessageOk.responseMessage)
}
inline void MessageOk::set_responsemessage(const char* value,
    size_t size) {
  
  responsemessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hydroponic.MessageOk.responseMessage)
}
inline std::string* MessageOk::_internal_mutable_responsemessage() {
  
  return responsemessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MessageOk::release_responsemessage() {
  // @@protoc_insertion_point(field_release:hydroponic.MessageOk.responseMessage)
  return responsemessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageOk::set_allocated_responsemessage(std::string* responsemessage) {
  if (responsemessage != nullptr) {
    
  } else {
    
  }
  responsemessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), responsemessage,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hydroponic.MessageOk.responseMessage)
}

// -------------------------------------------------------------------

// MessageError

// string errorType = 1;
inline void MessageError::clear_errortype() {
  errortype_.ClearToEmpty();
}
inline const std::string& MessageError::errortype() const {
  // @@protoc_insertion_point(field_get:hydroponic.MessageError.errorType)
  return _internal_errortype();
}
inline void MessageError::set_errortype(const std::string& value) {
  _internal_set_errortype(value);
  // @@protoc_insertion_point(field_set:hydroponic.MessageError.errorType)
}
inline std::string* MessageError::mutable_errortype() {
  // @@protoc_insertion_point(field_mutable:hydroponic.MessageError.errorType)
  return _internal_mutable_errortype();
}
inline const std::string& MessageError::_internal_errortype() const {
  return errortype_.Get();
}
inline void MessageError::_internal_set_errortype(const std::string& value) {
  
  errortype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MessageError::set_errortype(std::string&& value) {
  
  errortype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hydroponic.MessageError.errorType)
}
inline void MessageError::set_errortype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  errortype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:hydroponic.MessageError.errorType)
}
inline void MessageError::set_errortype(const char* value,
    size_t size) {
  
  errortype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hydroponic.MessageError.errorType)
}
inline std::string* MessageError::_internal_mutable_errortype() {
  
  return errortype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MessageError::release_errortype() {
  // @@protoc_insertion_point(field_release:hydroponic.MessageError.errorType)
  return errortype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageError::set_allocated_errortype(std::string* errortype) {
  if (errortype != nullptr) {
    
  } else {
    
  }
  errortype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errortype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hydroponic.MessageError.errorType)
}

// -------------------------------------------------------------------

// MessageTimeout

// string timeoutMessage = 1;
inline void MessageTimeout::clear_timeoutmessage() {
  timeoutmessage_.ClearToEmpty();
}
inline const std::string& MessageTimeout::timeoutmessage() const {
  // @@protoc_insertion_point(field_get:hydroponic.MessageTimeout.timeoutMessage)
  return _internal_timeoutmessage();
}
inline void MessageTimeout::set_timeoutmessage(const std::string& value) {
  _internal_set_timeoutmessage(value);
  // @@protoc_insertion_point(field_set:hydroponic.MessageTimeout.timeoutMessage)
}
inline std::string* MessageTimeout::mutable_timeoutmessage() {
  // @@protoc_insertion_point(field_mutable:hydroponic.MessageTimeout.timeoutMessage)
  return _internal_mutable_timeoutmessage();
}
inline const std::string& MessageTimeout::_internal_timeoutmessage() const {
  return timeoutmessage_.Get();
}
inline void MessageTimeout::_internal_set_timeoutmessage(const std::string& value) {
  
  timeoutmessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MessageTimeout::set_timeoutmessage(std::string&& value) {
  
  timeoutmessage_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hydroponic.MessageTimeout.timeoutMessage)
}
inline void MessageTimeout::set_timeoutmessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timeoutmessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:hydroponic.MessageTimeout.timeoutMessage)
}
inline void MessageTimeout::set_timeoutmessage(const char* value,
    size_t size) {
  
  timeoutmessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hydroponic.MessageTimeout.timeoutMessage)
}
inline std::string* MessageTimeout::_internal_mutable_timeoutmessage() {
  
  return timeoutmessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MessageTimeout::release_timeoutmessage() {
  // @@protoc_insertion_point(field_release:hydroponic.MessageTimeout.timeoutMessage)
  return timeoutmessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageTimeout::set_allocated_timeoutmessage(std::string* timeoutmessage) {
  if (timeoutmessage != nullptr) {
    
  } else {
    
  }
  timeoutmessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timeoutmessage,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hydroponic.MessageTimeout.timeoutMessage)
}

// -------------------------------------------------------------------

// Command

// .hydroponic.CMD command = 1;
inline void Command::clear_command() {
  command_ = 0;
}
inline ::hydroponic::CMD Command::_internal_command() const {
  return static_cast< ::hydroponic::CMD >(command_);
}
inline ::hydroponic::CMD Command::command() const {
  // @@protoc_insertion_point(field_get:hydroponic.Command.command)
  return _internal_command();
}
inline void Command::_internal_set_command(::hydroponic::CMD value) {
  
  command_ = value;
}
inline void Command::set_command(::hydroponic::CMD value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:hydroponic.Command.command)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hydroponic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hydroponic::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hydroponic::MessageType>() {
  return ::hydroponic::MessageType_descriptor();
}
template <> struct is_proto_enum< ::hydroponic::CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hydroponic::CMD>() {
  return ::hydroponic::CMD_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hydroponic_5fdata_2eproto
